; Uniforms
.fvec projection[4], model[4], view[4]

; Constants
.constf common_const(0.0, 1.0, 0.5, 0.003921568393707275390625)
.alias  zeros  common_const.xxxx ; Vector full of 0.0
.alias  ones   common_const.yyyy ; Vector full of 1.0
.alias  half   common_const.zzzz ; Vector full of 0.5
.alias  clrdiv common_const.wwww ; Vector full of 1/255 (float24 approximation)

; Outputs
.out outpos position
.out outtc0 texcoord0
.out outtc1 texcoord1
.out outclr color
.out outview view
.out outnq normalquat

; Inputs (defined as aliases for convenience)
; v3 isn't used in the 3D shader since blend is useless here
.in inpos v0 ; position
.in intex v1 ; texture coordinates
.in innrm v2 ; normals
.in inclr v4 ; color

.proc main
	; Vertex position vectors.
	mov r0.xyz, inpos.xyz
	mov r0.w, common_const.y

	; r1 = model matrix, (model matrix * vertex positions)
	dp4 r2.x, model[0], r0
	dp4 r2.y, model[1], r0
	dp4 r2.z, model[2], r0
	dp4 r2.w, model[3], r0

	; r1 = view matrix, (view * results)
	dp4 r1.x, view[0], r2
	dp4 r1.y, view[1], r2
	dp4 r1.z, view[2], r2
	dp4 r1.w, view[3], r2

	; outview = -r1
	mov outview, -r1

	; outpos = model projection matrix, (projection * results)
	dp4 outpos.x, projection[0], r1
	dp4 outpos.y, projection[1], r1
	dp4 outpos.z, projection[2], r1
	dp4 outpos.w, projection[3], r1

	; outtex = intex
	mov outtc0, intex
	mov outtc1, intex

	; Transform the normal vector with the model matrix
	dp3 r14.x, model[0], innrm
	dp3 r14.y, model[1], innrm
	dp3 r14.z, model[2], innrm
	dp3 r6.x, r14, r14
	rsq r6.x, r6.x
	mul r14.xyz, r14.xyz, r6.x

	mov r0, common_const.yxxx
	add r4, ones, r14.z
	mul r4, half, r4
	cmp zeros, ge, ge, r4.x
	rsq r4, r4.x
	mul r5, half, r14
	jmpc cmp.x, degenerate

	rcp r0.z, r4.x
	mul r0.xy, r5, r4

degenerate:
	mov outnq, r0
	mul outclr, clrdiv, inclr

	; We're finished
	end
.end
